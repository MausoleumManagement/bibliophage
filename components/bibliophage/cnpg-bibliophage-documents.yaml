# pretty much based on this https://blog.ferretdb.io/run-ferretdb-postgres-documentdb-extension-cnpg-kubernetes/
apiVersion: postgresql.cnpg.io/v1
kind: Cluster
metadata:
  name: bibliophage-documents
spec:
  imageCatalogRef:
    apiGroup: postgresql.cnpg.io
    kind: ClusterImageCatalog
    name: documentdb-bookworm
    major: 17
  instances: 3
  # UID and GID are required like this by the documentDB image
  postgresUID: 999
  postgresGID: 999
  superuserSecret:
    name: db-superuser
  bootstrap:
    initdb:
      database: documents
      owner: bibliophage
      secret:
        name: db-standard-user
      # this creates the extension *before* the  application database is made available
      # to any clients, so there is no weirdness with a client
      # talking to a fresh DB without it
      # note that this is different from postInitSQL, which is executed against the `postgres` db
      # k explain clusters.postgresql.cnpg.io.spec.bootstrap.initDb
      #postInitSQL:
      postInitApplicationSQL:
        # CASCADE will enable all dependencies as well, which includes  pg_cron and pg_documentdb_core
        - 'CREATE EXTENSION IF NOT EXISTS documentdb CASCADE;'
        # mongosh/ferretdb will attempt to set this parameter and fail if it cannot
        # see https://github.com/FerretDB/FerretDB/issues/4997#issuecomment-2780636246
        # the documentdb_admin_role is apparently also needed
        # a nice side effect of this is, that it allows accessing the 
        # postgres DB as the application user usign e.g. DBeaver without
        # getting errors about missing permissions on the documentdb schemas
        - 'GRANT SET ON PARAMETER documentdb.maxuserlimit TO bibliophage;'
        - 'GRANT documentdb_admin_role TO bibliophage;'
  postgresql:
    # this is the declarative part ensuring the extensions are enabled
    # but since this is managed after the DB is made available
    # we have the postInitSQL step too
    shared_preload_libraries:
      - pg_cron
      - pg_documentdb_core
      - pg_documentdb
    pg_hba:
      # this entry allows any user on localhost to login as bibliophage on the documents db
      # not great, but it's the least annoying solution for the time being
      # see the tidbit below about the documentdb connection string as to why we do this
      - 'host documents bibliophage localhost trust'
    parameters:
      # documentsdb has a dependency on pg_cron
      # i have only found fragmentary documentation on this, but
      # pg_cron can seemingly only be run against a single database
      # https://github.com/citusdata/pg_cron?tab=readme-ov-file#setting-up-pg_cron
      # and documentdb seems to have a requirement for that being the database that the documentdb extension is running in
      # see the tidbit about the cron.database_name parameter here
      # https://blog.ferretdb.io/run-ferretdb-postgres-documentdb-extension-cnpg-kubernetes/#create-the-postgresql-cluster
      cron.database_name: 'documents'
      # pg_cron needs to be able to authenticate to the database to start cronjobs
      # so to allow the database to talk to itself, we tell it to use the default postgresql unix domain socket
      # leaving the string empty does that for us
      # https://github.com/citusdata/pg_cron?tab=readme-ov-file#ensuring-pg_cron-can-start-jobs
      cron.host: ''
      # documentdb needs to connect back to itself using libpq
      # it would be nice to use a socket here, but cnpg defines fixed entries  for socket connections in pg-hba.conf
      # that are evaluated before any additional user created ones
      # the way they are written means, that only 'postgres' can connect using a local socket connection and peer auth
      # that is not what we want, because ferretdb will connect using an application user
      # so for now, we will be using the regular IP network stack, even though this is all happening
      # locally
      # we can either pass a directory containing the postgresql socket files as a hostname
      # or a regular hostname / IP
      # we can find out where the socket is using the query
      # SELECT name, setting, short_desc, context FROM pg_settings  WHERE name LIKE '%socket%';
      #documentdb.localhost_connection_string: 'host=/controller/run user=bibliophage'
      documentdb.localhost_connection_string: 'host=localhost user=bibliophage'
  storage:
    size: 10Gi
  managed:
    services:
      additional:
        - selectorType: rw
          serviceTemplate:
            metadata:
              name: "bibliophage-documents-db-rw"
              annotations:
                kube-vip.io/loadbalancerIPs: 192.168.14.7
            spec:
              type: LoadBalancer
---
apiVersion: postgresql.cnpg.io/v1
kind: Database
metadata:
  name: bibliophage-documents
spec:
  name: documents
  owner: bibliophage
  cluster:
    name: bibliophage-documents
